# rust
* 文件名一般以`.rs`作为后缀
* `main`作为主函数, `rustc <Filename>`会生成一个可执行文件
* 也可以`cargo new <Projectname>`创建新工程, 通过`cargo run`启动
* 每行需要加分号结尾

## 注释
* 普通注释
    * `//`作为单行注释
    * `/* xxx */`作为多行注释, 或者后面可以写其他代码的单行注释

## 文档
* 文档注释
    * `///`会显示为方法的描述
    * `//!`作为crate级别的描述, 会显示为一行
* 文档生成
    * cargo
        * 执行`cargo doc`会在`target/doc/<ProjectName>`目录下生成index.html
        * 执行`cargo doc --open`会自动打开文档
    * rustdoc
        * 执行`rustdoc <Filename>`在当前目录下生成doc目录和文件

## 打印
* 输出类别
    * print! 输出到控制台
    * println! 换行输出到控制台(stdout 通道1)
    * eprint! 输出到异常管道
    * eprintln! 换行输出到异常管道(stderr 通道2)
    * 分别接受2个管道的值, 例如`cargo run 1>1.txt 2>2.txt`
* 格式化语法
    * `format!`只做格式化, 例如`let name = "liy"; let output = format!("name is {name}"); println!("{}", output);`
    * 可以直接打印字符串
    * 也可以第一个参数作为格式化字符串, 后续为格式化使用的参数
        * 字符串中的`{}`会替换为后面的参数, 例如`println!("{}", 123);`
        * 如果不指定索引, 两者数量必须一致, 自动按顺序替换, 例如`println!("{} - {}", 1, 2);`
        * 如果指定索引, 数量可以不一致, 但是参数必须全部使用过, 索引从0开始, 例如`println!("{1} - {0}", 1, 2);`
        * 还可以用变量名的形式, 例如`println!("{name} - {age}", name="liy", age=30);`
            * 变量可以定义在上文, 不是一定在print中, 例如`let name = "liy"; println!("{name}");`
    * 通过`:`格式化
        * 支持进制转换, 默认输出10进制
            * `:b`转为二进制, 例如`println!("{:b}", 8);`
            * `:o`转为八进制
            * `:x`转为十六进制
        * 支持填充
            * `>`输出内容放在右侧, 即在左侧填充
                * 左侧为填充内容, 默认填充空格, 右侧为填充后的目标长度, 例如填充3个空格`println!("{:>4}", 8);`
                * 可以设置填充内容, 例如使用问号填充`println!("{:?>4}", 8);`
                * 填充目标长度可以是变量, 变量名以`$`结尾, 例如`println!("{:x>l$}", 8, l=3);`
                    * 长度变量也可以在上文获取
            * `<`输出内容放在左侧, 即在右侧填充, 填充内容和目标长度参数位置不变, 例如`println!("{:3<4}", 8);`
* 自定义数据结构不能直接打印
    * 通过添加`#[derive(Debug)]`可以打印自定义结构
        * 无法定义输出格式
        * 打印时格式化字符串要使用`{:?}`, 或者`{:#?}`美化打印
    * 自定义输出规则, 需要实现`fmt::Display`接口的`fmt`方法
        * 实现后使用`{}`而不是`{:?}`来打印

## 基本类型
* 类型
    * 标量
        * 有符号整数: i8, i16, i32, i64, i128, isize
        * 无符号整数: u8, u16, u32, u64, u128, usize
        * 浮点数: f32, f64
        * 字符类型: char, 使用单引号包裹, 4个字节
        * 布尔类型: bool, 为`true`或者`false`
        * 空元组: ()
        * 以上数字类型可以通过下划线分隔, 不影响取值, 例如`println!("{}", 1.2_3);`
        * 支持科学记数法
        * 支持位运算符`&` `|` `^` `<<` `>>`
    * 元组
        * 通过小括号定义, 子元素类型不要求一致, 长度固定
        * 类型定义需要列出所有子元素类型, 例如`let tuple: (i8, bool) = (3, false);`
        * 可以解构取值, 例如`let (_, tuple2) = tuple;`
        * 也可以通过点加上下标取值, 下标从0开始, 例如`tuple.0`
        * 可以直接使用`{:?}`或者`{:#?}`打印不超过12位的元组
    * 数组
        * 通过中括号定义, 子元素类型要求一致, 长度固定
        * 类型定义需要指定类型和长度, 逗号分隔, 例如`let arr: [i8; 2] = [1, 2];`
        * 初始化数组可以用变量和数量的形式去填充, 例如`let arr = [1; 3];`
        * 可以解构取值, 例如`let [_, arr2] = arr;`
        * 也可以通过中括号加上下标取值, 下标从0开始, 例如`arr[0]`
        * len()方法获取长度, 例如`println!("{}", arr.len());`
        * 数组可以通过get方法传入索引来安全获取内容, 避免越界, 例如`println!("{:?}", arr.get(3));`
            * 正常数据返回`Some`并携带数据, 越界返回`None`
    * 切片
        * 类似于数组, 但是长度在编译时未知
        * 类型定义为`&[T]`, `T`为范型
        * 数组可以转为切片类型, 例如`let slice = &arr;`
        * 可以把数组的一部分转为切片, 例如`let slice2 = &arr[0..1];`
            * 参数为开始位置索引和结束位置索引, 包前不包后
            * 开始位置则为0, 结束位置省略则为数组长度+1
* 定义
    * 通过`let`定义常量, 不能省略
        * 如果使用变量, 使用`mut`修饰, 例如`let mut num = 1; num = 2;`
            * 变量只能修改值, 不能修改类型
        * 常量不能修改, 但是可以重新定义, 类型也会改变, 例如`let num = 1; let num = true;`
    * 可以不指定类型让rust推断, 也可以通过冒号来指定, 例如`let num: i8  = 1;`
        * 数字类型可以通过后缀添加类型, 例如`let num  = 1i8;`

## 自定义类型
