# blender
* 菜单上直接ctrl+c可以复制命令
* ctrl+tab 切模式

## 小技巧
* blt汉化工具
* 开启面捕捉和旋转, 可以贴合面
* 不封闭的物体不能重构网格, 但是和封闭物体合并后可以进行重构

## 人物建模

### 头
* 入门先看头部比例, 拿球开始雕刻做细节了解结构, 看需求做拓扑
* 也可以面皮建模, 用平面卡线做出布线, 然后挤出配合衰减拉出厚度

### 眉毛
* 复制眉毛附近的平面并分离
* 添加材质并编辑
* 添加图像纹理, 新建纯黑材质, 连接到基础色
* 展uv
* 进入纹理绘制, 用白色画笔绘制眉毛形状[黑色地方长眉毛,越黑眉毛越多], 保存贴图
* 物体模式, 添加->曲线->空白毛发
* 切换到几何节点, 右侧修改器可以看到自带的surface, 新建一个几何节点放到他上面
* 选中毛发, 进入雕刻模式, 选择密度, 在上方工具栏curve shape[曲线形状]调长度, 减少控制点, 再开启x镜像 
* 视图着色方式从实体改为材质预览[右上的球], 开始添加毛发
* 选择梳理笔刷来调整角度
* 新增节点 set hair cure profile, 调整半径. 需要eevee渲染器, 并调节曲线->形状为strip
* 新增节点 interpolate hair curves, 来根据现有毛发插值生成更多毛发
    * 需要选择生长面[表(曲面)]为分离的平面
    * 新增命名节点, 选择矢量后选择UV贴图, 连接到表面UV贴图
    * 新增运算节点, 选择正片叠底[multiple], 第一个值调大, 第二个值手动控制, 连接到密度
    * 遮罩纹理选择刚刚绘制的纹理图
    * 添加设置材质节点, 添加一个毛发的材质[可以去材质里用原理化毛发bsdf节点做]
* 调整生长面可以用缩裹选头部调整, 最后应用掉

### 睫毛
* 睫毛和眉毛类似
* 分离平面, 展uv[不用纹理遮罩因为绕着眼睛生长]
* 注意内眼角不需要长, 可以删了这些面
* 添加空白毛发
* 生长/收缩工具可以调整毛发长度, ctrl是减少长度[下睫毛比上睫毛短]
* 上下睫毛分别添加和梳理后, 调整几何节点
    * set hair cure profile 调整粗细
    * interpolate hair curves 插值生长
    * clump hair curves 成簇效果[guide distance越小, 簇越多 / 形状越小越狭长]
        * 配合分离几何体节点, 一部分成簇, 另一部分自然生长
        * 放在插值和簇集之间, 修改点为样条线, 选中项连接一个随机数
        * 簇集节点后加合并几何节点, 用于将分离几何体的反相合并到簇集结果
* 最后上材质

### 眼睛
* 自动眼[auto eye]插件, 需要eevee渲染器, 开启屏幕空间反射->折射才能看见瞳孔
* 分为3个材质: 
    * iris[虹膜]
        * fiberas: 中间的颜色
        * dark ring: 外圈颜色
        * collarette: 内外圈中间部分
    * cornea/sclera[角膜/巩膜]
        * sclera相关: 调整外圈
        * veins: 静脉[就是血丝]
        * softness柔软度: 前后颜色混合边界强弱
        * position位置: 前后颜色分界线
    * pupil[瞳孔]
* 顶点组的形态键可以调整大小
    * 

## 烘焙
* 法线烘焙: 让简模有高模的效果
    * 法线[法向]: 决定面的正反, 和光反射的方向
* 复制一份低模, 来雕刻成为高模
* 为低模添加图像纹理
* 先选低模, 再加选择高模, 右侧工具栏, 使用cycles引擎, 烘焙->类型[法向], 选择所选物体->活动物体, 输出目标选图像纹理, 记得把结果图保存
    * 出现黄色说明匹配度不够, 再所选物体->活动物体的展开项, 增加挤出的量
* 选择低模[展好uv的], 图像纹理选择保存的图像[选择非彩色,不能rgb], 连接到[矢量]法线贴图颜色, 最后连接到材质的法向
* bpainter烘焙: 创建一个图像纹理, 烘焙结束后保存图片, 图像纹理连接原理化bsdf到输出即可导出

## 导入unity
* 导出到unity先解包, 选择fbx格式, 路径选择复制
* 把bpainter纹理烘焙成一张纹理可以导出到unity
* unity的控制器如果选人型, 要求骨骼必须有父子关系
    * 点rig, 动画类型选'人型', avatar定义选'从此模型创建', 点配置进入配置页
    * 异常的骨骼是红色, 点击其上层骨骼, 可以在左侧看到子孙关系, 选择对应的子骨骼修正
* 用blender的auto rig pro插件做的骨骼的父子关系不满足unity, 所以选泛型
* 

## 骨骼动画
* 绑定之前要把缩放都应用掉
* IK
    * 控制骨要分离父子关系
    * 先选控制骨, 然后选要控制的骨骼和控制骨连接的骨头
        * 例如小腿推断大腿, 就选控制骨和小腿
    * shift+i, 添加ik
    * 链长就是黄色的骨头开始, 能控制几个骨头
    * 小腿可以 骨骼属性->反向运动学, 把ik的y和z轴锁住, 防止内外八字
    * 极向目标可以用来控制 控制骨 能抬多高, 还能移动来控制骨骼角度
* 自带的插件 rigify, 也可以直接生成控制器
    * 物体数据属性 -> rigify -> generate rig
    * n菜单里把ik拉伸调整成0, 不然胳膊会拉长
        * fk[正向运动]用不上也可以关了
* 在线自动绑定功能[mixamo]
    * 做好的模型导出fbx, 上传到网页, 指定关节点, 会自动绑定骨骼
    * blender也有对应的mixamo插件, 来把下载回来的fbx生成控制器
* 权重绘制
    * 蓝色不受影响, 红色完全影响, 在右面菜单选顶点组来切换骨骼
    * 物体数据属性->层, 可以调整骨骼和控制器显示
    * 把物体合并, 然后选择骨骼, 加选模型, 进入绘制页, ctrl点选骨骼绘制
        * auto rig pro 层选右下角的
        * rigify 层选右侧倒数第3个
    * n菜单, 笔刷可以控制增加还是减少权重
    * n菜单, 选项, 勾选自动规格化[一个骨骼增加,其他就减少]
    * 可以做几个简单关键帧, 来看调整效果
* 穿模处理
    * 做形态键, 然后雕刻模型拉模型
* 绑定武器
    * 单手武器可以用子级约束选手的骨骼
    * 还可以用骨骼方式来控制
        * rigigy在右侧菜单去新增骨骼, 用自定义属性控制特效, 然后绑定物体
        * 手部挤出一个骨骼, 断开骨骼连接, 然后子级约束

## 绑定衣服
* 数据传递
    * 选择衣服, 添加数据传递修改器
    * 源, 吸附身体, 勾选顶点数据
    * 展开菜单, 选择顶点组, 映射选择最近的顶点
    * 点击生成数据层, 顶点组下拉就产生了数据
    * 应用修改器
    * 再选择衣服, 添加骨架修改器
    * 选择人体骨架, 勾选维持体积
* 绑定骨骼方式
    * auto rig pro插件不能手动插骨骼, 需要在go之后, 通过 add limb 来添加
        * 衣服可以选最后一个 bendy bones
        * 加完骨骼需要指定父对象
    * limb option 可以改骨骼的段数, 并指定位置
    * 建议用n菜单的复制, 然后对称也用n菜单的[dupi mirror]
    * 像头发这样的也可以单独做骨骼
    * 生成控制器后, 把要上一步骨骼控制的布料都选上再蒙皮
* 低精度绑定可以直接表面变形修改器


## 道具制作
* 手套: 复制手, 然后编辑->法线缩放
* 用简易变形修改器做弯曲很方便
* 高模雕刻时候
    * 手抖, 可以改笔画的描边方式为曲线或者直线
        * ctrl + 右键 拖出曲线控制点, 最少拖2次, 满意后回车根据曲线雕刻
    * 细节不够, 用简化笔刷+动态拓扑, 可以局部丰富网格数
    * 遮罩绘制出要调整的区域, 然后ctrl+i反选, 再进行雕刻
        * alt + m 删除所有遮罩

## 自定义属性
* 右侧菜单新增自定义属性, 然后复制属性路径
    * blender里使用值的地方, 可以添加驱动器, 指定成复制的路径
        * var就是自定义属性, 可以做表达式
    * frame就是跟随帧数变化

## 特效制作
* 曲线: [路径效果]用贝塞尔曲线, 帧数控制起点和结束点系数
* 形态键: [比如用平面做拖尾效果]做几组形态, 渐变纹理用线性, 然后对应帧的对应键设成1
* 贴图: [比如发射的剑气]渐变纹理用球形, 

## 几何节点特效
* 分离几何体配合运算进行过滤
* 已命名属性可以拿到位置等信息
* xyz的分离和合并可以单独调整一个方向
* 但是几何节点做的没法导出fbx

# 配合unity

## blender部分
* 面朝向, 蓝色代表发现向外, 红色代表发现向内
* 集合的过滤器下拉, 点出小箭头, 去掉勾选则无法选中
* 蒙皮修改器会增加体积, 可以通过该修改器建模
    * 创建平面, 合并所有点, 添加镜像+蒙皮+表面细分修改器, 挤出点进行建模
    * 蒙皮修改器需要标记根点
    * ctrl+a 调节半径, 可以配合xyz单独调整
* 轴心点调整为活动元素, shift点击2次变成白色, 即可绕点旋转
* 关节处可以v拆分, 然后桥接, 增加关节拐点面数
* 头部uv放大, 需要五官的细节
* 脚可以用复制旋转修改器来复制ik的旋转, 方向不对可以修改目标和拥有者为局部空间
* ctrl + p 附带空顶点组, 然后用数据传输把顶点组数据带过来就能绑定衣服
* 还是要做A/T pose, 不然衣服权重很乱
* 原点放在脚下

### 手持武器
* 在身体骨架上, 做一个空父级的骨骼, 然后武器绑定骨骼, 把权重刷到这个骨骼上
* 这个骨骼摆好位置后, 设置子级约束, 做动画时候注意这个骨骼不要记录帧, 烘焙动画, 勾选所有项目, 就会把约束烘焙成帧动画

## unity部分
* 创建3d-urp工程, 不需要版本控制
* 导入时候需要导入对应贴图
* 勾选动画的循环时间并应用
* 注意原点位置

### 地面
* 添加一个平面, 充值位置后等比例缩放给他放大
* 创建材质, 点击基础贴图前面的圆圈(可以选择棋盘格), 然后把材质拖到地面上绑定
    * 还可以指定基础色来更改棋盘格颜色
* 更改 正在平铺 属性, 可以改变棋盘格大小

### urp
* 选择global volume, 右侧的Tonemapping的模式属性, 修改为aces
* 添加覆盖 -> post-processing -> color adjustments, 并移动到最上方
    * 右侧...菜单, 移动到最上方
    * 选择全部, 调整一下属性
* 泛光的强度可以提高亮度
* vignette是遮罩效果

### 状态机
* 新建一个animation controller[动画器控制器], 赋值给角色的animator的控制器
* 双击控制器, 右键 创建状态 -> 从新的混合树
* 双击混合树, 右侧parameter的motion是空列表, 添加运动域[数量和动画数量一致]
    * 点击圆圈为运动域添加动画
    * 依次添加 静止/走路/跑步 的动画
* 左侧参数栏, 可以修改参数名, 0~1的值对应了混合树播放效果
* 注意导入的动画预制件外面套空物体, 不然位置受动画影响

#### 混合动画
* 用混合动画实现一部分放一个动画, 另一部分放其他动画[例如拔刀同时走路]
* 导入时候, 为动画配置遮罩, 哪些需要动的地方, 勾选上
* 动画机创建新层, 指定动画并配置权重即可
* 可以配合动画事件
    * 动画检查器里面, 事件新增函数, 控制器对象新增脚本并增加该函数即可调用
    * 可以播放完把权重归0
* 过度动画的settings可以设置中断源, current就是立即中断当前动画播放下一个动画



### 脚本控制角色
* 创建C#脚本, 场景内创建空物体, 模型作为空物体子级. 脚本拖到空物体上
* 首选项 -> 外部工具 -> 外部脚本编辑器, 选择vscode, 重置参数并点击 regenerate project files, 双击脚本打开
    * vscode 代码提示不好
* 旋转控制的脚本
```
// 获取输入
Vector2 input = new Vector2(Input.GetAxis("Horizontal"), Input.GetAxis("Vertical"));
Vector2 inputDir = input.normalized;

// 有输入才调整旋转, 防止自动归位
if (inputDir != Vector2.zero) {
    transform.eulerAngles = Vector3.up * (Mathf.Atan2(inputDir.x, inputDir.y) * Mathf.Rad2Deg);
}
```
* 移动控制
    * 先为空物体添加 Character Controller 组件, 高度和blender尺寸对应, 调整中心参数, 对齐模型
    * 对应脚本
    ```
    // 控制移动
    // 获取左shift是否按下
    bool isRunning = Input.GetKey(KeyCode.LeftShift);
    // 速度控制
    float speed = (isRunning ? runSpeed : walkSpeed) * inputDir.magnitude;
    // 浮点转换向量
    Vector3 speedVec = transform.forward * speed;
    // 移动位置
    characterController.Move(speedVec * Time.deltaTime);
    // 获取状态对应的动画参数
    float moveStatus = (isRunning ? 1 : 0.5f) * inputDir.magnitude;
    // 修改动画控制器参数
    animator.SetFloat("MoveStatus", moveStatus);
    ```

### 第三人称摄像机
* 创建脚本, 挂载到主摄像机
* 获取鼠标的横纵旋转, 乘算灵敏度, 赋值给相机旋转
```
// 跟随鼠标旋转
yaw += Input.GetAxis("Mouse X") * mouseSensitivity;
pitch -= Input.GetAxis("Mouse Y") * mouseSensitivity;
// 控制在min/max范围内
pitch = Mathf.Clamp(pitch, pitchLimit.x, pitchLimit.y);
// 转换为向量
Vector3 vec = new Vector3(pitch, yaw);
// 挂载在摄像机上, 所以直接更改旋转值即可
transform.eulerAngles = vec;
// 控制相机位置
transform.position = target.position - transform.forward * cameraOffset;
```
* 暴露目标属性, 在玩家空物体下创建目标空物体, 调整到头位置
* 可以设置旋转范围, 保证视角合理
* 相机旋转最好影响角色旋转
```
transform.eulerAngles = Vector3.up * (Mathf.Atan2(inputDir.x, inputDir.y) * Mathf.Rad2Deg + cameraTransform.eulerAngles.y);
```
* 可以隐藏光标防止影响操作
```
Cursor.lockState = CursorLockMode.Locked;
Cursor.visible = false;
```

### 敌人
* 创建胶囊碰撞体[capsule collider], 开启trigger
* 创建刚体 rigidbody, 并关闭重力影响
* 脚本控制追踪玩家: 通过tag查找GameObject, 用distance计算距离, 满足条件LookAt朝向玩家并移动
* OnTriggerEnter为触发刚体事件, 可以判断参数的tag属性区分
* Instantiate可以实例化预制件

### 小地图
* 为物体添加层, 并关闭阴影
* 新增摄像机, 添加遮罩
* 为第二个摄像机output添加大小来显示