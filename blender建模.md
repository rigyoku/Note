# blender
* 菜单上直接ctrl+c可以复制命令
* ctrl+tab 切模式

## 小技巧
* blt汉化工具
* 开启面捕捉和旋转, 可以贴合面
* 不封闭的物体不能重构网格, 但是和封闭物体合并后可以进行重构

## 写实人物建模

### 头
* 入门先看头部比例, 拿球开始雕刻做细节了解结构, 看需求做拓扑
* 也可以面皮建模, 用平面卡线做出布线, 然后挤出配合衰减拉出厚度

### 眉毛
* 复制眉毛附近的平面并分离
* 添加材质并编辑
* 添加图像纹理, 新建纯黑材质, 连接到基础色
* 展uv
* 进入纹理绘制, 用白色画笔绘制眉毛形状[黑色地方长眉毛,越黑眉毛越多], 保存贴图
* 物体模式, 添加->曲线->空白毛发
* 切换到几何节点, 右侧修改器可以看到自带的surface, 新建一个几何节点放到他上面
* 选中毛发, 进入雕刻模式, 选择密度, 在上方工具栏curve shape[曲线形状]调长度, 减少控制点, 再开启x镜像 
* 视图着色方式从实体改为材质预览[右上的球], 开始添加毛发
* 选择梳理笔刷来调整角度
* 新增节点 set hair cure profile, 调整半径. 需要eevee渲染器, 并调节曲线->形状为strip
* 新增节点 interpolate hair curves, 来根据现有毛发插值生成更多毛发
    * 需要选择生长面[表(曲面)]为分离的平面
    * 新增命名节点, 选择矢量后选择UV贴图, 连接到表面UV贴图
    * 新增运算节点, 选择正片叠底[multiple], 第一个值调大, 第二个值手动控制, 连接到密度
    * 遮罩纹理选择刚刚绘制的纹理图
    * 添加设置材质节点, 添加一个毛发的材质[可以去材质里用原理化毛发bsdf节点做]
* 调整生长面可以用缩裹选头部调整, 最后应用掉

### 睫毛
* 睫毛和眉毛类似
* 分离平面, 展uv[不用纹理遮罩因为绕着眼睛生长]
* 注意内眼角不需要长, 可以删了这些面
* 添加空白毛发
* 生长/收缩工具可以调整毛发长度, ctrl是减少长度[下睫毛比上睫毛短]
* 上下睫毛分别添加和梳理后, 调整几何节点
    * set hair cure profile 调整粗细
    * interpolate hair curves 插值生长
    * clump hair curves 成簇效果[guide distance越小, 簇越多 / 形状越小越狭长]
        * 配合分离几何体节点, 一部分成簇, 另一部分自然生长
        * 放在插值和簇集之间, 修改点为样条线, 选中项连接一个随机数
        * 簇集节点后加合并几何节点, 用于将分离几何体的反相合并到簇集结果
* 最后上材质

### 眼睛
* 自动眼[auto eye]插件, 需要eevee渲染器, 开启屏幕空间反射->折射才能看见瞳孔
* 分为3个材质: 
    * iris[虹膜]
        * fiberas: 中间的颜色
        * dark ring: 外圈颜色
        * collarette: 内外圈中间部分
    * cornea/sclera[角膜/巩膜]
        * sclera相关: 调整外圈
        * veins: 静脉[就是血丝]
        * softness柔软度: 前后颜色混合边界强弱
        * position位置: 前后颜色分界线
    * pupil[瞳孔]
* 顶点组的形态键可以调整大小

### 粒子头发
* 添加粒子系统, 选择毛发, 数量改0, 进入粒子编辑模式绘制发际线
* 添加平面, 添加几何节点
    * 添加曲线直线节点, y改成1, xz是0
    * 添加曲线重采样节点, 头发越长, 数量给越大
    * 添加曲线到网格节点
* 添加粒子实例修改器, 吸附模型, 勾选沿路径创建
* 添加几何节点
    * 添加网格到曲线节点
    * 从资产库拖入毛发
* 粒子的渲染改成无, 防止影响视线
* 引导曲线节点连出去的, 要通过引导曲线连线, 不能连几何数据
* 最后通过曲线到网格进行输出, 轮廓曲线可以选圆环, 让头发都是圆
* 通过样条线参数节点的系数连接到设置曲线半径节点, 可以让曲线头尾不一样粗[如果粗细反了,使用反转曲线节点]
* 注意毛发数量, 不然导出时候面数爆炸了


## 烘焙
* 法线烘焙: 让简模有高模的效果
    * 法线[法向]: 决定面的正反, 和光反射的方向
* 复制一份低模, 来雕刻成为高模
* 为低模添加图像纹理
* 先选低模, 再加选择高模, 右侧工具栏, 使用cycles引擎, 烘焙->类型[法向], 选择所选物体->活动物体, 输出目标选图像纹理, 记得把结果图保存
    * 出现黄色说明匹配度不够, 再所选物体->活动物体的展开项, 增加挤出的量
* 选择低模[展好uv的], 图像纹理选择保存的图像[选择非彩色,不能rgb], 连接到[矢量]法线贴图颜色, 最后连接到材质的法向
* bpainter烘焙: 创建一个图像纹理, 烘焙结束后保存图片, 图像纹理连接原理化bsdf到输出即可导出

## 导入unity
* 导出到unity先解包, 选择fbx格式, 路径选择复制
* 把bpainter纹理烘焙成一张纹理可以导出到unity
* unity的控制器如果选人型, 要求骨骼必须有父子关系
    * 点rig, 动画类型选'人型', avatar定义选'从此模型创建', 点配置进入配置页
    * 异常的骨骼是红色, 点击其上层骨骼, 可以在左侧看到子孙关系, 选择对应的子骨骼修正
* 用blender的auto rig pro插件做的骨骼的父子关系不满足unity, 所以选泛型
* 

## 骨骼动画
* 绑定之前要把缩放都应用掉
* IK
    * 控制骨要分离父子关系
    * 先选控制骨, 然后选要控制的骨骼和控制骨连接的骨头
        * 例如小腿推断大腿, 就选控制骨和小腿
    * shift+i, 添加ik
    * 链长就是黄色的骨头开始, 能控制几个骨头
    * 小腿可以 骨骼属性->反向运动学, 把ik的y和z轴锁住, 防止内外八字
    * 极向目标可以用来控制 控制骨 能抬多高, 还能移动来控制骨骼角度
* 自带的插件 rigify, 也可以直接生成控制器
    * 物体数据属性 -> rigify -> generate rig
    * n菜单里把ik拉伸调整成0, 不然胳膊会拉长
        * fk[正向运动]用不上也可以关了
* 在线自动绑定功能[mixamo]
    * 做好的模型导出fbx, 上传到网页, 指定关节点, 会自动绑定骨骼
    * blender也有对应的mixamo插件, 来把下载回来的fbx生成控制器
* 权重绘制
    * 蓝色不受影响, 红色完全影响, 在右面菜单选顶点组来切换骨骼
    * 物体数据属性->层, 可以调整骨骼和控制器显示
    * 把物体合并, 然后选择骨骼, 加选模型, 进入绘制页, ctrl点选骨骼绘制
        * auto rig pro 层选右下角的
        * rigify 层选右侧倒数第3个
    * n菜单, 笔刷可以控制增加还是减少权重
    * n菜单, 选项, 勾选自动规格化[一个骨骼增加,其他就减少]
    * 可以做几个简单关键帧, 来看调整效果
* 穿模处理
    * 做形态键, 然后雕刻模型拉模型
* 绑定武器
    * 单手武器可以用子级约束选手的骨骼
    * 还可以用骨骼方式来控制
        * rigigy在右侧菜单去新增骨骼, 用自定义属性控制特效, 然后绑定物体
        * 手部挤出一个骨骼, 断开骨骼连接, 然后子级约束

## 绑定衣服
* 数据传递
    * ctrl+p 空顶点组
    * 选择衣服, 添加数据传递修改器
    * 源, 吸附身体, 勾选顶点数据
    * 展开菜单, 选择顶点组, 映射选择最近的顶点
    * 点击生成数据层, 顶点组下拉就产生了数据
    * 应用修改器
* 绑定骨骼方式
    * auto rig pro插件不能手动插骨骼, 需要在go之后, 通过 add limb 来添加
        * 衣服可以选最后一个 bendy bones
        * 加完骨骼需要指定父对象
    * limb option 可以改骨骼的段数, 并指定位置
    * 建议用n菜单的复制, 然后对称也用n菜单的[dupi mirror]
    * 像头发这样的也可以单独做骨骼
    * 生成控制器后, 把要上一步骨骼控制的布料都选上再蒙皮
* 低精度绑定可以直接表面变形修改器


## 道具制作
* 手套: 复制手, 然后编辑->法线缩放
* 用简易变形修改器做弯曲很方便
* 高模雕刻时候
    * 手抖, 可以改笔画的描边方式为曲线或者直线
        * ctrl + 右键 拖出曲线控制点, 最少拖2次, 满意后回车根据曲线雕刻
    * 细节不够, 用简化笔刷+动态拓扑, 可以局部丰富网格数
    * 遮罩绘制出要调整的区域, 然后ctrl+i反选, 再进行雕刻
        * alt + m 删除所有遮罩

## 自定义属性
* 右侧菜单新增自定义属性, 然后复制属性路径
    * blender里使用值的地方, 可以添加驱动器, 指定成复制的路径
        * var就是自定义属性, 可以做表达式
    * frame就是跟随帧数变化

## 特效制作
* 曲线: [路径效果]用贝塞尔曲线, 帧数控制起点和结束点系数
* 形态键: [比如用平面做拖尾效果]做几组形态, 渐变纹理用线性, 然后对应帧的对应键设成1
* 贴图: [比如发射的剑气]渐变纹理用球形

## 几何节点特效
* 分离几何体配合运算进行过滤
* 已命名属性可以拿到位置等信息
* xyz的分离和合并可以单独调整一个方向
* 但是几何节点做的没法导出fbx

## 布料
* 平面添加物理属性->布料, 人物添加物理属性->碰撞
* 平面添加细分, 播放动画即可
* 质量倍数控制品质
* 速率倍增控制播放速度, 1和时间轴一致, 越慢计算效果越好
* 子项目碰撞参数, 启动自碰撞防止穿插
* 计算结束后再添加细分
* 布料属性对应不同的材质效果, 例如质量减少像是丝绸
* 内部弹簧模拟床垫效果
* 压力可以模拟枕头, 需要2个面中间连着线[仅面的删除], 形状栏的缝合可以把2个面连接起来
    * 面如果有破损, 就会喷气..., 可以把力场的质量降低让他起飞
* 效果可以烘焙进行保存, 还可以单独保存成文件
* 钉固可以把对应顶点固定住
    * 顶点组需要指定, 可以用选择按钮确定哪些点在组里
* 缩放因子负数就会先放大
* 布料修改器可以应用导出

### 补充
* 模型的摩擦拉大防止穿模, 调小可以让衣服贴合
* 碰撞的最小距离需要小于初始距离, 不然特别卡
* 衣服上软的饰品可以缝合上去, 硬的饰品可以用约束关联


## 面皮建模
* 平面, 正视图做出脸型, 下巴向前拉, 挤出鼻子侧脸的线
* 单侧, 嘴8边型, 眼睛10边型, 鼻子下斜面2个面
* 眼睛内侧第二个下边连接鼻子的第2个下斜面, 上面的做一圈
* 鼻子的第2个下斜面挤出面绕嘴
* 眼睛外侧2边连接脸边缘, 连接到下巴
* 嘴外侧2边连接脸边缘

## 碎片效果
* 使用 cell fracture 插件
* 选择物体后, 在物体菜单->快速效果->cell fracture启动

## uv
* 开启校正面属性, 在拉物体, uv就不会拉伸
* 物体数据属性 -> uv贴图 可以创建多个uv
* 可以分别为uv绘制贴图, 着色器的uv连接到贴图的矢量, 指定为裁剪防止影响额外区域
* 最后新建一个空贴图, 新uv, 选择贴图+uv进行烘焙成一个图, 删除多余uv再导出

## 拓扑
* 一个四边形, 用顶点+2个中点可以拆分成3个四边形, 用于完成1个面到2个面的过度, 类似于I的内插面
* 在四边形内, K出3个边形成梯形, 3个边再分别连出四边形, 完成1个面到3个面的过度
* 四边形做圆角, 可以在一个角的2个顶点合并到中心, 删除外层多余点形成拐角
* 关节等形变大的部位, 需要更多的几何体来保持体积. 需要将一条边拆成2个循环边
    * 可以以v拆分, 然后桥接, 增加关节拐点面数
    * 也可内插, 再把边缘点合并, 删除中间多余边形成四边面

## 纹理
* alt + 左键 吸色

## 模型后期修正
* 可以复制一个骨骼修改器, 然后前一个摆好姿势应用掉, 然后把骨架移动旋转清空掉之后姿态模型应用为初始姿态, 就可以修改初始姿态


# 配合unity

## blender部分
* 面朝向, 蓝色代表发现向外, 红色代表发现向内
* 集合的过滤器下拉, 点出小箭头, 去掉勾选则无法选中
* 蒙皮修改器会增加体积, 可以通过该修改器建模
    * 创建平面, 合并所有点, 添加镜像+蒙皮+表面细分修改器, 挤出点进行建模
    * 蒙皮修改器需要标记根点
    * ctrl+a 调节半径, 可以配合xyz单独调整
* 轴心点调整为活动元素, shift点击2次变成白色, 即可绕点旋转
* 关节处可以v拆分, 然后桥接, 增加关节拐点面数
* 头部uv放大, 需要五官的细节
* 脚可以用复制旋转修改器来复制ik的旋转, 方向不对可以修改目标和拥有者为局部空间
* ctrl + p 附带空顶点组, 然后用数据传输把顶点组数据带过来就能绑定衣服
* 还是要做A/T pose, 不然衣服权重很乱
* 原点放在脚下

### 手持武器
* 在身体骨架上, 做一个空父级的骨骼, 然后武器绑定骨骼, 把权重刷到这个骨骼上
* 这个骨骼摆好位置后, 设置子级约束, 做动画时候注意这个骨骼不要记录帧, 烘焙动画, 勾选所有项目, 就会把约束烘焙成帧动画

### 剑气
* 渐变球形纹理为什么能做剑气: 因为展开UV之后拉平了, 半球就是剑气形状, 越边缘白色越少
* 拉平uv: 选择一个面的2个边对齐x轴, 另外2边对齐y轴, 面模式, 沿活动四边面展开, 就能拉平
* 同理三角形贴图就能实现开头宽, 结尾窄效果

### 冰锥
* 可以从低面数棱角球拉出来

### rigify
* 新增的骨骼, 姿态模型->骨架->rigify type指定类型, weight type选bone
* 武器可以选basic.pivot, 开启控制器并开启选择父元素
* 关节防止形变可以额外加一个骨骼, 类型选皮肤基本链, 需要绑定父级不然乱飞
* 形变骨才有权重

### 资源
* https://www.mixamo.com/#/ 可以直接下载带动画的模型

### 低面曲线头发
* 截面和曲线的u向分辨率都调低


## unity部分
* 创建3d-urp工程, 不需要版本控制
* 导入时候需要导入对应贴图
* 勾选动画的循环时间并应用
    * 最好都加上, 防止事件不触发
* 注意原点位置
* GetComponentInChildren 也会包括当前节点, 获取到第一个匹配项

### 地面
* 添加一个平面, 充值位置后等比例缩放给他放大
* 创建材质, 点击基础贴图前面的圆圈(可以选择棋盘格), 然后把材质拖到地面上绑定
    * 还可以指定基础色来更改棋盘格颜色
* 更改 正在平铺 属性, 可以改变棋盘格大小
* 用fbx导入的需要设置mesh collider组件, 不然没碰撞

### urp
* 选择global volume, 右侧的Tonemapping的模式属性, 修改为aces
* 添加覆盖 -> post-processing -> color adjustments, 并移动到最上方
    * 右侧...菜单, 移动到最上方
    * 选择全部, 调整一下属性
* 泛光的强度可以提高亮度
* vignette是遮罩效果

### 状态机
* 新建一个animation controller[动画器控制器], 赋值给角色的animator的控制器
* 双击控制器, 右键 创建状态 -> 从新的混合树
* 双击混合树, 右侧parameter的motion是空列表, 添加运动域[数量和动画数量一致]
    * 点击圆圈为运动域添加动画
    * 依次添加 静止/走路/跑步 的动画
* 左侧参数栏, 可以修改参数名, 0~1的值对应了混合树播放效果
* 注意导入的动画预制件外面套空物体, 不然位置受动画影响

#### 混合动画
* 用混合动画实现一部分放一个动画, 另一部分放其他动画[例如拔刀同时走路]
* 导入时候, 为动画配置遮罩, 哪些需要动的地方, 勾选上
* 动画机创建新层, 指定动画并配置权重即可
* 可以配合动画事件
    * 动画检查器里面, 事件新增函数, 控制器对象新增脚本并增加该函数即可调用
    * 可以播放完把权重归0
* 过度动画的settings可以设置中断源, current就是立即中断当前动画播放下一个动画



### 脚本控制角色
* 创建C#脚本, 场景内创建空物体, 模型作为空物体子级. 脚本拖到空物体上
* 首选项 -> 外部工具 -> 外部脚本编辑器, 选择vscode, 重置参数并点击 regenerate project files, 双击脚本打开
    * vscode 代码提示不好
* 旋转控制的脚本
```
// 获取输入
Vector2 input = new Vector2(Input.GetAxis("Horizontal"), Input.GetAxis("Vertical"));
Vector2 inputDir = input.normalized;

// 有输入才调整旋转, 防止自动归位
if (inputDir != Vector2.zero) {
    transform.eulerAngles = Vector3.up * (Mathf.Atan2(inputDir.x, inputDir.y) * Mathf.Rad2Deg);
}
```
* 移动控制
    * 先为空物体添加 Character Controller 组件, 高度和blender尺寸对应, 调整中心参数, 对齐模型
    * 对应脚本
    ```
    // 控制移动
    // 获取左shift是否按下
    bool isRunning = Input.GetKey(KeyCode.LeftShift);
    // 速度控制
    float speed = (isRunning ? runSpeed : walkSpeed) * inputDir.magnitude;
    // 浮点转换向量
    Vector3 speedVec = transform.forward * speed;
    // 移动位置
    characterController.Move(speedVec * Time.deltaTime);
    // 获取状态对应的动画参数
    float moveStatus = (isRunning ? 1 : 0.5f) * inputDir.magnitude;
    // 修改动画控制器参数
    animator.SetFloat("MoveStatus", moveStatus);
    ```

### 第三人称摄像机
* 创建脚本, 挂载到主摄像机
* 获取鼠标的横纵旋转, 乘算灵敏度, 赋值给相机旋转
```
// 跟随鼠标旋转
yaw += Input.GetAxis("Mouse X") * mouseSensitivity;
pitch -= Input.GetAxis("Mouse Y") * mouseSensitivity;
// 控制在min/max范围内
pitch = Mathf.Clamp(pitch, pitchLimit.x, pitchLimit.y);
// 转换为向量
Vector3 vec = new Vector3(pitch, yaw);
// 挂载在摄像机上, 所以直接更改旋转值即可
transform.eulerAngles = vec;
// 控制相机位置
transform.position = target.position - transform.forward * cameraOffset;
```
* 暴露目标属性, 在玩家空物体下创建目标空物体, 调整到头位置
* 可以设置旋转范围, 保证视角合理
* 相机旋转最好影响角色旋转
```
transform.eulerAngles = Vector3.up * (Mathf.Atan2(inputDir.x, inputDir.y) * Mathf.Rad2Deg + cameraTransform.eulerAngles.y);
```
* 可以隐藏光标防止影响操作
```
Cursor.lockState = CursorLockMode.Locked;
Cursor.visible = false;
```

### 敌人
* 创建胶囊碰撞体[capsule collider], 开启trigger
* 创建刚体 rigidbody, 并关闭重力影响
* 脚本控制追踪玩家: 通过tag查找GameObject, 用distance计算距离, 满足条件LookAt朝向玩家并移动
* OnTriggerEnter为触发刚体事件, 可以判断参数的tag属性区分
* Instantiate可以实例化预制件

### 小地图
* 为物体添加层, 并关闭阴影
* 新增摄像机, 正交视图
* 通过层控制哪些显示
* 为第二个摄像机output添加大小[小于1]来显示

### UI
* 画布也最好重置一下

#### 技能栏
* canvas的ui缩放模式最好选屏幕大小缩放
* 创建图像UI, 需要把导入的图片转sprite才能使用
    * 选图片, 右侧检查器, 纹理类型选sprite, 模式选单一, 应用
* 技能栏: canvas加上空节点, 使用grid-layout-group组件表格布局来条件间距
* cd效果
    * 技能图片添加子图片元素, 锚点选择中心[alt选择stresh], 图片选择相同的图, 实现覆盖效果
    * imagetype从简单选择已填充, 让他可以转
    * 颜色给一个灰色表示技能正在cd, 顺时针取消勾选控制方向
    * 再添加一个文本作为子元素来显示计时

#### 血条和伤害
* 主角的固定血条直接用已填充类型图片做就行
* 移动血条也是加图片, 但是渲染模型选世界空间
* 伤害数字也是放到预制体中, 可以通过透明度让他淡出

### 碰撞检测

#### 2d
* 给角色创建一个空物体作为子对象, 添加Polygon Collider 2d[多边形碰撞]
* 拖动点框选范围, 点击线就会增加点
* 在动画指定帧来启动, 其他帧关闭
    * 动画窗口, 添加属性, 选择对应的gameobject.isactive属性

#### 3d
* 也是子对象, 加box碰撞就行, 加到武器底下, 控制形状
    * 加到骨骼上, 不要加在单独的物体上, 不然不会跟着动
* 也可以用脚本事件修改碰撞器活性[enabled]
* 接收的物体, 用Collisision系列方法处理碰撞, 进入是OnCollisionEnter
* 触发者必须拥有刚体组件, 可以冻结xyz和取消重力
* 勾选trigger触发OnTriggerEnter事件, 不勾选触发OnCollisionEnter
    * trigger不会移动物体, 不勾选会导致物体移动

#### 粒子
* 粒子碰撞可以在监视器直接开启, 默认球形, 可以通过半径缩放
* 对应碰撞事件是是OnParticleCollision, 粒子和另一个碰撞体都是
* game窗口才能看到碰撞, 播放看不到事件, 发送碰撞消息记得勾选
    * 碰撞质量选高, 不然还是可能看不到事件
* 选了子发射器, 位置就固定了改不了了


### 特效

#### 拖尾[刀光]
* 勾选粒子自带的拖尾
* 创建材质, shader选择lit, 表面类型选择transparent透明的
* 渲染器的渲染模型改成无[因为不需要粒子本身], 并指定材质
* 调整形状为矩形, 对齐到武器, 调整拖尾大小和数量, 速度给小点
* 控制时间对齐动画, 用脚本需要先取出变量main保存一下再操作

#### 剑气
* 也是粒子系统, 去掉形状, 爆发一个
* 渲染器的模式改成网格, 指定剑气模型, 渲染对齐选择局部, 使用ParticlesUnlit就能出现剑气波

##### 使用shader美化[和blender渲染器类似]
* 创建 -> shadergraph -> urp -> 无光照shadergraph, 双击展开编辑
* 添加[sample texture 2d]指定贴图
* 右侧检查器, 选择[graph settings], 在universal的surfacetype改为transparent透明的, 并指定out到alpha上
* 用gradient noise+multiply混合做随机
* remap节点做映射, 按比例映射
* 通过tilling and offset配和time让刀光有动态效果
* 最后创建color和out相乘, mode选hdr
* 创建材质并指定shader, 赋值给粒子
* 需要左上角save asset保存
* uv进行split分离之后, b对应customerdata的x, 连接到tilling进行密度缩放, 最后指到贴图的uv上, 进行控制
    * 渲染器下勾选自定义顶点流, 添加一个custom1.x
        * 因为uv的x和y已经使用了r和g两个通道, 自定义的就是b开始
    * 勾选自定义数据, 模式选矢量, 组件数量选1, 调整x就能对应到tilling进行缩放

#### 溶解效果
* step节点, 输入大于edge[边缘], 返回1, 输入小于边缘返回0
* 可以配合噪点, 调整边缘值, 最后输出到alpha完成随机消失
* 通过uv的r和g[x和y坐标], 配合step+alpha可以做到从头到尾的逐步显示效果

#### 冰锥
* 粒子做爆发效果
* shader做中心透明效果: fresenl effect
* 外层颜色和基础色相加, 如果相乘内部就是透明的了
* 向上生长, 所以y不旋转, 把x和z旋转
* 生命周期内速度限制就是阻力效果

#### 涟漪/漩涡
* radial shear 配合噪声 生成涟漪
* twirl 配合噪声 生成漩涡
* 用到生命周期的颜色, 需要vertex color乘一下
* alpha clip 小于该值会被过滤变成透明
* rotate 节点让uv旋转
* scene color 透视过去的颜色[需要在settings -> urp-hight fidelity勾选opaque texture]
    * uv接到screen position处理后的输出就能做到扭曲

### 暂停动画
* animator.speed = 0;